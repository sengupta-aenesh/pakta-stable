import { NextRequest, NextResponse } from 'next/server'
import { getCurrentUser } from '@/lib/auth-server'
import { apiErrorHandler } from '@/lib/api-error-handler'
import { captureContractError, addSentryBreadcrumb, setSentryUser } from '@/lib/sentry-utils'
import { OpenAI } from 'openai'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

export const POST = apiErrorHandler(async (request: NextRequest) => {
  const user = await getCurrentUser()
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // Set user context for Sentry
  setSentryUser({
    id: user.id,
    email: user.email
  })

  const { action, contractContent, selectedText } = await request.json()

  if (!action || !contractContent || !selectedText) {
    return NextResponse.json({ 
      error: 'Missing required fields: action, contractContent, selectedText' 
    }, { status: 400 })
  }

  // Add breadcrumb for text action
  addSentryBreadcrumb(`Text action started: ${action}`, 'contract', 'info', {
    action,
    userId: user.id,
    selectedTextLength: selectedText.length
  })

  try {
    let result

    if (action === 'explain') {
      result = await handleExplainAction(contractContent, selectedText)
    } else if (action === 'redraft') {
      result = await handleRedraftAction(contractContent, selectedText)
    } else {
      return NextResponse.json({ 
        error: 'Invalid action. Must be "explain" or "redraft"' 
      }, { status: 400 })
    }

    // Add success breadcrumb
    addSentryBreadcrumb(`Text action completed: ${action}`, 'contract', 'info', {
      action,
      success: true
    })

    return NextResponse.json(result)

  } catch (error) {
    // Capture text action specific error
    captureContractError(error as Error, undefined, `text_action_${action}`, {
      action,
      userId: user.id,
      selectedTextLength: selectedText?.length,
      contractContentLength: contractContent?.length
    })
    throw error // Re-throw for apiErrorHandler to handle
  }
})

async function handleExplainAction(contractContent: string, selectedText: string) {
  const systemPrompt = `You are a senior legal expert with 30+ years of experience in contract law and a JD from Harvard Law School. Your role is to explain selected legal text in clear, accessible terms for business professionals.

When analyzing legal text:
- Explain what the clause means in plain English
- Identify any potential risks, benefits, or obligations
- Mention any legal implications or requirements
- Provide context within typical business practices
- Keep explanations concise but comprehensive
- Use bullet points for complex concepts when helpful
- Focus on practical business impact

Be professional, accurate, and helpful. Avoid overly technical legal jargon unless necessary.`

  const userPrompt = `Please explain this legal text from a contract:

Selected Text: "${selectedText}"

Contract Context (first 2000 chars): "${contractContent.substring(0, 2000)}${contractContent.length > 2000 ? '...' : ''}"

Provide a clear explanation of:
1. What this clause means in plain English
2. Any risks, benefits, or obligations it creates
3. Practical business implications
4. Any red flags or important considerations`

  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ],
    temperature: 0.3,
    max_tokens: 1000
  })

  const explanation = response.choices[0]?.message?.content?.trim()
  
  if (!explanation) {
    throw new Error('No explanation generated by AI')
  }

  return { explanation }
}

async function handleRedraftAction(contractContent: string, selectedText: string) {
  const systemPrompt = `You are a senior contract attorney with expertise in drafting clear, enforceable legal language. Your role is to improve legal text by making it clearer, more balanced, and legally sound while maintaining the original intent.

When redrafting legal text:
- Maintain the original legal intent and effect
- Improve clarity and readability
- Remove ambiguous language where possible
- Balance risks fairly between parties
- Use modern legal drafting standards
- Ensure enforceability
- Maintain professional legal tone
- Keep the same scope and obligations

Your response should be structured as:
1. REDRAFTED TEXT: [The improved version]
2. EXPLANATION: [Brief explanation of changes made and why]`

  const userPrompt = `Please redraft this legal text to improve clarity and balance while maintaining the same legal intent:

Selected Text: "${selectedText}"

Contract Context (first 2000 chars): "${contractContent.substring(0, 2000)}${contractContent.length > 2000 ? '...' : ''}"

Provide:
1. REDRAFTED TEXT: An improved version that maintains the same legal effect but with better clarity
2. EXPLANATION: What changes were made and why they improve the clause

Focus on improving readability while keeping the same legal obligations and scope.`

  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ],
    temperature: 0.3,
    max_tokens: 1500
  })

  const content = response.choices[0]?.message?.content?.trim()
  
  if (!content) {
    throw new Error('No redraft generated by AI')
  }

  // Parse the structured response
  let redraftedText = ''
  let explanation = ''

  // Look for the structured format
  const redraftMatch = content.match(/REDRAFTED TEXT:\s*(.*?)(?=\n\s*EXPLANATION:|$)/is)
  if (redraftMatch) {
    redraftedText = redraftMatch[1].trim()
  }

  const explanationMatch = content.match(/EXPLANATION:\s*(.*?)$/is)
  if (explanationMatch) {
    explanation = explanationMatch[1].trim()
  }

  // Fallback parsing if structured format not found
  if (!redraftedText || !explanation) {
    // Try alternative patterns
    const altRedraftMatch = content.match(/(?:redrafted text|improved text|revised text)[:\s]*["']?(.*?)["']?(?=\n\n|\nexplanation|\nchanges made)/is)
    if (altRedraftMatch) {
      redraftedText = altRedraftMatch[1].trim()
    }

    const altExplanationMatch = content.match(/(?:explanation|changes made|improvements)[:\s]*(.*?)$/is)
    if (altExplanationMatch) {
      explanation = altExplanationMatch[1].trim()
    }
  }

  // Final fallback: split by double newlines
  if (!redraftedText || !explanation) {
    const parts = content.split(/\n\n+/)
    if (parts.length >= 2) {
      redraftedText = parts[0].replace(/^(?:redrafted text|improved text)[:\s]*/i, '').trim()
      explanation = parts.slice(1).join('\n\n').replace(/^(?:explanation|changes made)[:\s]*/i, '').trim()
    } else {
      // If all parsing fails, treat the whole response as redrafted text
      redraftedText = content
      explanation = 'Text has been improved for clarity and legal precision.'
    }
  }

  // Clean up the redrafted text (remove quotes if wrapped)
  redraftedText = redraftedText.replace(/^["']|["']$/g, '').trim()

  if (!redraftedText) {
    throw new Error('Could not extract redrafted text from AI response')
  }

  return { 
    redraftedText,
    explanation: explanation || 'Text has been improved for clarity and legal precision.'
  }
}